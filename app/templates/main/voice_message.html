{% extends "base.html" %}

{% block content %}
<div class="container mt-4">
    <div class="row">
        <div class="col-md-8 mx-auto">
            <div class="card">
                <div class="card-header bg-primary text-white">
                    <h4>{{ _('Voice Message') }}</h4>
                </div>
                <div class="card-body">
                    <div class="alert alert-info">
                        <p>{{ _('To use voice messaging, please:') }}</p>
                        <ol>
                            <li>{{ _('Allow microphone access when your browser asks for permission') }}</li>
                            <li>{{ _('Click the "Start Recording" button below') }}</li>
                            <li>{{ _('Speak your message clearly') }}</li>
                            <li>{{ _('Click "Stop Recording" when finished') }}</li>
                        </ol>
                    </div>
                    
                    <!-- Diagnostic information -->
                    <div class="alert alert-light border small">
                        <h6>{{ _('Diagnostic Information') }}</h6>
                        <div id="browser-info"></div>
                        <div id="audio-support"></div>
                    </div>
                    
                    <div id="mic-status" class="alert alert-secondary text-center">
                        {{ _('Waiting for microphone permission...') }}
                    </div>

                    <div class="text-center mb-4">
                        <div id="recording-timer" class="display-4 mb-3">00:00</div>
                        
                        <div id="recording-controls">
                            <button id="request-permission" class="btn btn-lg btn-primary mb-3">
                                <i class="fas fa-microphone me-2"></i> {{ _('Request Microphone Permission') }}
                            </button>
                            
                            <div class="d-none" id="recording-buttons">
                                <button id="start-record" class="btn btn-lg btn-success me-2">
                                    <i class="fas fa-microphone"></i> {{ _('Start Recording') }}
                                </button>
                                <button id="stop-record" class="btn btn-lg btn-danger d-none">
                                    <i class="fas fa-stop"></i> {{ _('Stop Recording') }}
                                </button>
                            </div>
                        </div>
                        
                        <div id="processing" class="d-none">
                            <div class="spinner-border text-primary" role="status">
                                <span class="visually-hidden">{{ _('Processing...') }}</span>
                            </div>
                            <p>{{ _('Processing your voice message...') }}</p>
                        </div>
                    </div>
                    
                    <div class="d-none" id="results-section">
                        <h5>{{ _('Results:') }}</h5>
                        <div class="card mb-3">
                            <div class="card-header">{{ _('Your message:') }}</div>
                            <div class="card-body">
                                <p id="transcript-text"></p>
                            </div>
                        </div>
                        
                        <div class="card">
                            <div class="card-header">{{ _('Assistant response:') }}</div>
                            <div class="card-body">
                                <p id="response-text"></p>
                            </div>
                        </div>
                        
                        <div class="text-center mt-3">
                            <button id="return-to-chat" class="btn btn-primary" data-session-id="{{ session_id }}">
                                {{ _('Return to Chat') }}
                            </button>
                            <button id="new-recording" class="btn btn-outline-secondary">
                                {{ _('New Recording') }}
                            </button>
                        </div>
                    </div>
                    
                    <!-- Debug Log -->
                    <div class="mt-4">
                        <a class="btn btn-sm btn-outline-secondary" data-bs-toggle="collapse" href="#debugLogCollapse">
                            {{ _('Show Debug Log') }}
                        </a>
                        <div class="collapse mt-2" id="debugLogCollapse">
                            <div class="card card-body bg-light">
                                <small class="text-muted">{{ _('Debug log:') }}</small>
                                <pre id="debug-log" class="small text-muted" style="max-height: 200px; overflow-y: auto;"></pre>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
let mediaRecorder = null;
let audioChunks = [];
let recordingInterval = null;
let recordingSeconds = 0;
let sessionId = "{{ session_id }}";

// Start recording timer
function startRecordingTimer() {
    recordingSeconds = 0;
    updateRecordingTime();
    recordingInterval = setInterval(() => {
        recordingSeconds++;
        updateRecordingTime();
    }, 1000);
}

// Stop recording timer
function stopRecordingTimer() {
    if (recordingInterval) {
        clearInterval(recordingInterval);
        recordingInterval = null;
    }
}

// Update recording time display
function updateRecordingTime() {
    const minutes = Math.floor(recordingSeconds / 60);
    const seconds = recordingSeconds % 60;
    document.getElementById('recording-timer').innerText = 
        `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
}

// Request permission for microphone
function requestMicrophonePermission() {
    logDebug('Requesting microphone permission');
    
    const micStatus = document.getElementById('mic-status');
    micStatus.className = 'alert alert-info text-center';
    micStatus.innerText = "{{ _('Requesting microphone access...') }}";
    
    // Log audio constraints
    const constraints = { audio: true };
    logDebug(`Using audio constraints: ${JSON.stringify(constraints)}`);
    
    navigator.mediaDevices.getUserMedia(constraints)
        .then(stream => {
            logDebug('Microphone permission granted');
            
            // Log stream information
            const audioTracks = stream.getAudioTracks();
            logDebug(`Audio tracks: ${audioTracks.length}`);
            
            audioTracks.forEach((track, index) => {
                logDebug(`Audio track ${index}: ID=${track.id}, Kind=${track.kind}, Label=${track.label}`);
                logDebug(`Track settings: ${JSON.stringify(track.getSettings())}`);
                logDebug(`Track constraints: ${JSON.stringify(track.getConstraints())}`);
            });
            
            micStatus.className = 'alert alert-success text-center';
            micStatus.innerText = "{{ _('Microphone access granted!') }}";
            
            // Hide permission button, show recording controls
            document.getElementById('request-permission').classList.add('d-none');
            document.getElementById('recording-buttons').classList.remove('d-none');
            
            // Store the stream for later use
            window.microphoneStream = stream;
            logDebug('Microphone stream stored for later use');
        })
        .catch(error => {
            logDebug(`Error accessing microphone: ${error.name} - ${error.message}`);
            if (error.name === 'NotAllowedError') {
                logDebug('User denied microphone permission');
            } else if (error.name === 'NotFoundError') {
                logDebug('No microphone found on this device');
            } else if (error.name === 'NotReadableError') {
                logDebug('Microphone is already in use by another application');
            }
            
            micStatus.className = 'alert alert-danger text-center';
            micStatus.innerText = "{{ _('Microphone access denied or not available.') }}";
        });
}

// Start recording
function startRecording() {
    if (!window.microphoneStream) {
        logDebug('No microphone stream available');
        return;
    }
    
    logDebug('Starting recording');
    audioChunks = [];
    
    // Update UI
    document.getElementById('start-record').classList.add('d-none');
    document.getElementById('stop-record').classList.remove('d-none');
    document.getElementById('mic-status').innerText = "{{ _('Recording...') }}";
    document.getElementById('mic-status').className = 'alert alert-danger text-center';
    
    // Start timer
    startRecordingTimer();
    
    // Create media recorder with options
    try {
        // Get available MIME types
        const mimeTypes = [
            'audio/webm',
            'audio/webm;codecs=opus',
            'audio/ogg;codecs=opus',
            'audio/mp4',
            'audio/mpeg'
        ];
        
        // Find supported MIME type
        let selectedMimeType = null;
        for (const type of mimeTypes) {
            if (MediaRecorder.isTypeSupported(type)) {
                selectedMimeType = type;
                logDebug(`Found supported MIME type: ${selectedMimeType}`);
                break;
            } else {
                logDebug(`MIME type not supported: ${type}`);
            }
        }
        
        if (!selectedMimeType) {
            selectedMimeType = '';  // Use browser's default
            logDebug('No supported MIME type found, using browser default');
        }
        
        // Create recorder with options
        const options = { 
            mimeType: selectedMimeType,
            audioBitsPerSecond: 128000  // 128 kbps
        };
        
        logDebug(`Creating MediaRecorder with options: ${JSON.stringify(options)}`);
        mediaRecorder = new MediaRecorder(window.microphoneStream, options);
        
        // Log MediaRecorder state
        logDebug(`Initial state: ${mediaRecorder.state}`);
        logDebug(`Selected MIME type: ${mediaRecorder.mimeType}`);
        
        mediaRecorder.addEventListener('dataavailable', event => {
            logDebug(`Data available event: size=${event.data.size}, type=${event.data.type}`);
            audioChunks.push(event.data);
        });
        
        mediaRecorder.addEventListener('start', () => {
            logDebug('MediaRecorder started event fired');
        });
        
        mediaRecorder.addEventListener('error', error => {
            logDebug(`MediaRecorder error: ${error}`);
        });
        
        // Start recording with 1 second chunks
        mediaRecorder.start(1000);
        logDebug(`Recording started, state: ${mediaRecorder.state}`);
    } catch (error) {
        logDebug(`Error starting recording: ${error.name} - ${error.message}`);
        if (error.stack) {
            logDebug(`Error stack: ${error.stack}`);
        }
        document.getElementById('mic-status').className = 'alert alert-danger text-center';
        document.getElementById('mic-status').innerText = "{{ _('Error starting recording.') }}";
    }
}

// Stop recording
function stopRecording() {
    if (!mediaRecorder) {
        logDebug('No media recorder available');
        return;
    }
    
    logDebug(`Stopping recording, current state: ${mediaRecorder.state}`);
    logDebug(`Current audio chunks: ${audioChunks.length}`);
    
    // Update UI
    document.getElementById('recording-controls').classList.add('d-none');
    document.getElementById('processing').classList.remove('d-none');
    document.getElementById('mic-status').innerText = "{{ _('Processing recording...') }}";
    document.getElementById('mic-status').className = 'alert alert-info text-center';
    
    // Stop timer
    stopRecordingTimer();
    logDebug(`Recording duration: ${recordingSeconds} seconds`);
    
    // Add stop event listener
    try {
        // Make sure we only add the listener once
        const onStopHandler = () => {
            logDebug('MediaRecorder stop event fired');
            logDebug(`Final audio chunks: ${audioChunks.length}`);
            
            // Log each chunk
            audioChunks.forEach((chunk, index) => {
                logDebug(`Chunk ${index}: size=${chunk.size}, type=${chunk.type}`);
            });
            
            sendAudioToServer();
        };
        
        // Remove existing listeners to avoid duplicates
        mediaRecorder.removeEventListener('stop', onStopHandler);
        mediaRecorder.addEventListener('stop', onStopHandler);
        
        // Stop the recorder
        logDebug('Calling mediaRecorder.stop()');
        mediaRecorder.stop();
        logDebug(`After stop() call, state: ${mediaRecorder.state}`);
        
        // Also stop the microphone tracks
        if (window.microphoneStream) {
            const tracks = window.microphoneStream.getTracks();
            tracks.forEach(track => {
                logDebug(`Stopping track: ${track.label}`);
                track.stop();
            });
            logDebug('All microphone tracks stopped');
        }
    } catch (error) {
        logDebug(`Error stopping recording: ${error.name} - ${error.message}`);
        if (error.stack) {
            logDebug(`Error stack: ${error.stack}`);
        }
        document.getElementById('mic-status').className = 'alert alert-danger text-center';
        document.getElementById('mic-status').innerText = "{{ _('Error stopping recording.') }}";
    }
}

// Send audio to server
function sendAudioToServer() {
    logDebug('Sending audio to server');
    
    // Try to determine best MIME type based on available chunks
    let mimeType = 'audio/webm';
    if (audioChunks.length > 0 && audioChunks[0].type) {
        mimeType = audioChunks[0].type;
        logDebug(`Using MIME type from first chunk: ${mimeType}`);
    }
    
    // Create audio blob with MIME type
    logDebug(`Creating Blob with type ${mimeType} from ${audioChunks.length} chunks`);
    const audioBlob = new Blob(audioChunks, { type: mimeType });
    logDebug(`Audio blob created: size=${audioBlob.size} bytes, type=${audioBlob.type}`);
    
    // Check if audio is too short
    if (audioBlob.size < 1000) {
        logDebug(`Audio too short: ${audioBlob.size} bytes`);
        document.getElementById('mic-status').className = 'alert alert-warning text-center';
        document.getElementById('mic-status').innerText = "{{ _('Recording too short.') }}";
        resetUI();
        return;
    }
    
    // Create form data
    logDebug('Creating FormData object');
    const formData = new FormData();
    
    // Determine file extension based on MIME type
    let fileExtension = 'webm';
    if (mimeType.includes('ogg')) fileExtension = 'ogg';
    else if (mimeType.includes('mp3')) fileExtension = 'mp3';
    else if (mimeType.includes('wav')) fileExtension = 'wav';
    
    const filename = `recording_${Date.now()}.${fileExtension}`;
    logDebug(`Generated filename: ${filename}`);
    
    // Add form data
    formData.append('audio', audioBlob, filename);
    formData.append('session_id', sessionId);
    const language = document.documentElement.lang || 'en';
    formData.append('language', language);
    
    logDebug(`Form data prepared with session_id=${sessionId}, language=${language}`);
    
    // Log request preparation
    logDebug('Preparing fetch request to /api/send_voice_message');
    
    // Send to server
    fetch('/api/send_voice_message', {
        method: 'POST',
        body: formData
    })
    .then(response => {
        logDebug(`Server response received. Status: ${response.status} ${response.statusText}`);
        
        // Log response headers
        const headers = {};
        response.headers.forEach((value, key) => {
            headers[key] = value;
        });
        logDebug(`Response headers: ${JSON.stringify(headers)}`);
        
        if (!response.ok) {
            throw new Error(`Server responded with status ${response.status}`);
        }
        
        return response.json().catch(e => {
            logDebug(`Error parsing JSON response: ${e.message}`);
            throw new Error('Invalid JSON in response');
        });
    })
    .then(data => {
        logDebug(`Server response data: ${JSON.stringify(data)}`);
        
        if (data.error) {
            logDebug(`Error from server: ${data.error}`);
            document.getElementById('mic-status').className = 'alert alert-danger text-center';
            document.getElementById('mic-status').innerText = data.error;
            resetUI();
            return;
        }
        
        // Show results
        document.getElementById('processing').classList.add('d-none');
        document.getElementById('results-section').classList.remove('d-none');
        document.getElementById('mic-status').className = 'alert alert-success text-center';
        document.getElementById('mic-status').innerText = "{{ _('Voice message processed successfully!') }}";
        
        // Display transcript and response
        const transcript = data.transcript || '';
        const response = data.response || '';
        
        logDebug(`Transcript: ${transcript}`);
        logDebug(`Response (first 100 chars): ${response.substring(0, 100)}...`);
        
        document.getElementById('transcript-text').innerText = transcript;
        document.getElementById('response-text').innerText = response;
        
        logDebug('Voice message processed successfully');
    })
    .catch(error => {
        logDebug(`Error in fetch: ${error.message}`);
        if (error.stack) {
            logDebug(`Error stack: ${error.stack}`);
        }
        
        document.getElementById('mic-status').className = 'alert alert-danger text-center';
        document.getElementById('mic-status').innerText = `{{ _('Error sending voice message:') }} ${error.message}`;
        resetUI();
    });
}

// Reset UI for new recording
function resetUI() {
    document.getElementById('processing').classList.add('d-none');
    document.getElementById('recording-controls').classList.remove('d-none');
    document.getElementById('start-record').classList.remove('d-none');
    document.getElementById('stop-record').classList.add('d-none');
    document.getElementById('recording-timer').innerText = '00:00';
}

// Debug log function
function logDebug(message) {
    const timestamp = new Date().toLocaleTimeString();
    const logElement = document.getElementById('debug-log');
    
    if (logElement) {
        // Add to UI log
        logElement.innerHTML += `[${timestamp}] ${message}\n`;
        // Auto-scroll to bottom
        logElement.scrollTop = logElement.scrollHeight;
    }
    
    // Log to console
    console.log(`[Voice Debug] ${message}`);
    
    // Also send to server
    try {
        fetch('/api/debug_log', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ 
                source: 'voice_message_html', 
                message: message,
                userAgent: navigator.userAgent
            })
        }).catch(e => console.error('Failed to send debug log:', e));
    } catch (e) {
        console.error('Error sending debug log:', e);
    }
}

// Add browser diagnostic information
function addBrowserDiagnostics() {
    const browserInfoElement = document.getElementById('browser-info');
    const audioSupportElement = document.getElementById('audio-support');
    
    if (browserInfoElement) {
        const browserInfo = `
            <p><strong>User Agent:</strong> ${navigator.userAgent}</p>
            <p><strong>Platform:</strong> ${navigator.platform}</p>
            <p><strong>App Version:</strong> ${navigator.appVersion}</p>
        `;
        browserInfoElement.innerHTML = browserInfo;
    }
    
    if (audioSupportElement) {
        const hasMediaDevices = !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);
        const hasAudioContext = 'AudioContext' in window || 'webkitAudioContext' in window;
        
        const supportInfo = `
            <p><strong>MediaDevices API:</strong> ${hasMediaDevices ? '✅ Supported' : '❌ Not supported'}</p>
            <p><strong>AudioContext API:</strong> ${hasAudioContext ? '✅ Supported' : '❌ Not supported'}</p>
            <p><strong>Secure Context:</strong> ${window.isSecureContext ? '✅ Yes' : '❌ No'}</p>
        `;
        audioSupportElement.innerHTML = supportInfo;
    }
}

// Initialize page
document.addEventListener('DOMContentLoaded', function() {
    // Add diagnostic information
    addBrowserDiagnostics();
    logDebug('Page loaded');
    logDebug(`Session ID: ${sessionId}`);
    
    // Add event listeners
    document.getElementById('request-permission').addEventListener('click', function() {
        logDebug('Request permission button clicked');
        requestMicrophonePermission();
    });
    
    document.getElementById('start-record').addEventListener('click', function() {
        logDebug('Start record button clicked');
        startRecording();
    });
    
    document.getElementById('stop-record').addEventListener('click', function() {
        logDebug('Stop record button clicked');
        stopRecording();
    });
    
    // Return to chat button
    const returnButton = document.getElementById('return-to-chat');
    if (returnButton) {
        returnButton.addEventListener('click', function() {
            const chatId = this.getAttribute('data-session-id');
            logDebug(`Returning to chat: ${chatId}`);
            window.location.href = `/chat/${chatId}`;
        });
    }
    
    // New recording button
    const newRecordingButton = document.getElementById('new-recording');
    if (newRecordingButton) {
        newRecordingButton.addEventListener('click', function() {
            logDebug('New recording button clicked');
            document.getElementById('results-section').classList.add('d-none');
            resetUI();
        });
    }
});
</script>
{% endblock %}
